Para modelos

1. El nombre de la clase este en singular, pero el
nombre de la colección este en plurar.

2. Usar @Document(collection = "nombre_en_plurar")
con snake_case

3. Usar @Id siempre para definir la clave primaria
private String id

4. Para fechas usar simpre LocalDateTime

5. Como busco aplanar las relaciones, en mongo
necesito que en la clase que pueda contender a la otra
se maneje asi por ejemplo: private List<BranchHoliday> branchHolidays;
y se llama a la clase respectiva que tiene como codigo:

package com.banquito.core.examen2p.model;

import lombok.Data;
import java.time.LocalDate;

@Data
public class BranchHoliday {
    private LocalDate date;
    private String name;
} 

NOTA: las clases que seran embebidas no tienen id

6. Para los repositorios necesito que usando el paquete: 
com.banquito.core.examen.repository 

Generes el archivo que lleve como nombre el nombre de 
la clase seguido del postfijo Repository
Debe hererdar de MongoRepository
Aqui se debera usar o declarar los metodos mas 
importantes y funcionales que tenga la clase, no quiero 
el listarTodos.


7. Para los servicios, usar INYECCION DE DEPENDENCIAS
Implementar metodos que sean funcionales y necesarios, no 
quiero borrar un registro de forma fisica, quiero 
hacerlo con un borrado lógico usando la propiedad estado
de la clase, usar @Transactional para los servicios que 
son CRUD, realizando validaciones para los registros,
las fechas deben ser generadas por automaticamente igual que la version

No usar optionals en los servicios para los metodos, usar la entidad
y si no hay respuesta lanzar la excepcion


Por ejemplo:
    @Transactional
    public Branch create(Branch branch) {
        branch.setCreationDate(LocalDateTime.now());
        branch.setLastModifiedDate(LocalDateTime.now());
        branch.setVersion(1L); // Version should be null for new entities
        branch.setBranchHolidays(new ArrayList<>());
        branch.setBranchPrices(new ArrayList<>());
        return branchRepository.save(branch);
    }
	
Considera generar en el servicio solo los metodos que 
tengan sentido en la vida real.

En los servicios por favor usa excepciones, crealas 
usando el paquete: com.banquito.core.exception
Estas excepciones deben heredarse de RunTimeException
Y deben usarse en el servicio

8. En los controladores usar documentacion de OpenApi de swagger
ya tengo la dependencia:
<dependency>
  <groupId>org.springdoc</groupId>
  <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
  <version>2.1.0</version>
</dependency>

9. Usar log de slf4j para el controlador, integrarlos de forma correcta
en las operaciones importantes, usar warm e info de preferencia
En los controladores tambien usar Inyeccion de dependencias
Usar buenas practicas para el nombrado de API´s

Por favor genera toda la documentación de los endpoints para probar
el registro.